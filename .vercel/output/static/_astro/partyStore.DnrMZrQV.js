import{F as g,n as d,o as l}from"./userStore.C5SZqrV9.js";const i=await new g,r=d({}),y=d({}),f=l({}),u=l({status:"",message:""}),e=l({status:"",message:""});async function A(s){try{const t=await i.registerParty(s);t&&r.setKey(t,{...s,id:t})}catch(t){u.set({status:"error",message:`Error: ${t.code}`})}}async function P(){try{(await i.getPartiesList()).map((t,n)=>{r.setKey(t.id||n.toString(),t)})}catch(s){u.set({status:"error",message:`Error: ${s.code}`})}}async function h(s,t){if(s?.admissionApplications?.some(n=>n===t))throw new Error("Application already sent");e.set({status:"loading",message:"Sending application..."});try{const n=s?.admissionApplications?.length?[...s?.admissionApplications,t]:[t],o=await i.updateParty(s,{...s,admissionApplications:n});return r.setKey(s.id,{...s,admissionApplications:n}),e.set({status:"success",message:"Application sent successfully. Waiting for approval..."}),o}catch(n){e.set({status:"error",message:`Error: ${n.code}`})}}async function E(s,t){e.set({status:"loading",message:"Accepting user..."}),console.log("e");try{console.log("trying",s,t);const n=s?.admissionApplications?.filter(c=>c!==t),o=s?.players?[...s?.players,t]:[t],a=await i.updateParty(s,{...s,admissionApplications:n,players:o,stats:[...s.stats,{userId:t,goals:0,victory:0}]});return r.setKey(s.id,{...s,admissionApplications:n,players:o,stats:[...s.stats,{userId:t,goals:0,victory:0}]}),console.log("AAAA",{...s,admissionApplications:n,players:o,stats:[...s.stats,{userId:t,goals:0,victory:0}]}),e.set({status:"success",message:"User accepted successfully."}),a}catch(n){u.set({status:"error",message:`Error: ${n.code}`})}}async function F(s,t){try{const n=await i.updateParty(s,{...s,stats:t});return r.setKey(s.id,{...s,stats:t}),n}catch(n){u.set({status:"error",message:`Error: ${n.code}`})}}async function K(s){const t=await i.getPartyById(s);if(!t)throw new Error("Party not found");const n=await m(t.players);if(!n)throw new Error("users not found");const o=t.stats.map(a=>{const c=n.find(p=>p.id===a.userId);if(!c)throw new Error("user not found");return{...a,user:c}});return f.set({...t,stats:o}),{...t,stats:o}}async function m(s){return await Promise.all(s.map(async n=>await i.getUserFromId(n)))}async function L(s){const t=await m(s);if(!t)throw new Error("users not found");return t.map((n,o)=>{y.setKey(n.id||o.toString(),n)}),t}export{L as a,y as b,e as c,E as d,A as e,P as f,K as g,r as h,h as i,u as j,f as p,F as r};
